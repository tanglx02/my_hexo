---
title: Python基础语法
date: 2024-04-24 09:32:16
categories: 
- 开发
tags: 
- 开发
- python
top: 
---
[toc]

# 基础语法
## 一、小功能
### 1.1 注释
注释的作用
> 解释代码
> 提示代码顺序 
> 记录修改代码 
> 暂时禁用代码块


1.加入#号注释
````
#print("注释")
````
2.快速注释 选中 ctrl+？
````
#print("注释")
#print("注释")
````
3.多行注释
````
"""
print("注释")
print("注释")
print("注释")
"""
````

## 二、变量和数据类型

### 2.1、变量的赋值
*普通字符需要使用双引号
数字不需要使用双引号，否则不能计算*

``` ini
age=22			 #数字类型
name="汤lx"		#普通类型
namne2="""
汤
l
x
"""			#三引号可以多行写变量
```
### 2.2、标识符
编写代码时，对变量，类，方法等编写的名字，叫做标识符


注意事项：
- 不能用数字开头
- 不能使用内置关键字作为变量
- 区分大小写
- 只能用中文、数字、下划线、英文命名

### 2.3、字符串
**字符串的三种定义法**
1)单引号定义法：name = 'helloword'
1)双引号定义法：name = "helloword"
1)三引号定义法：name = """helloword"""

**字符串的引号嵌用**
- 单引号定依法，可以内含双引号
- 双引号定依法，可以内含单引号
- 可以使用转移字符\来解除效用，变成普通字符串
### 2.4、数据类型
计算机中需要处理各种各样的数据，不同的数据，需要定义不同的数据类型

> 整型	浮点型	字符型	布尔型	空

- 整型(int)
例如：0，100，-8080，0
- 浮点型(float)
注意：整数和浮点数的存储方式不同，浮点运算时可能会产生一点误差。
- 字符型(str)
定义字符型要用单引号或者双引号
例如：'abc' "xyz"
- 布尔型(bool)
布尔值用于真假的判断，一个布尔值只有True，False两种值；
在Python中，可以直接用True，False表示布尔值（注意大小写）也可以表示式计算。

- 空(None)
空值表示什么也没有。
Nono不能理解为0，因为0是有意义的，，而None是一个特殊的空值。

## 三、数据类型的转换和运算符
### 3.1、数据类型转换
  **语法**
``` javascript
int(x) 		#将x转换为整数
float(x)	#将x转换为浮点数
str(x)		#将x转换为字符串
```
  注意事项
- 任何类型都可以转换成字符串
- 非数字字符串不能转换为数字
- 浮点数转小数会丢失精度

### 3.2、运算符
**基础运算符**
| 运算符 | 描述   | 备注            |
| ------ | ------ | --------------- |
| +      | 加     |                 |
| -      | 减     |                 |
| *      | 乘     |                 |
| /      | 除     |                 |
| //     | 取整除 | 11//2=5         |
| %      | 取余   | 11%2=1          |
| **     | 指数   | a**b,b是a的指数 |
**赋值运算符**
| 运算符 | 描述       | 备注                        |
| ------ | ---------- | --------------------------- |
| =      | 赋值运算符 | 把=号右边的值赋给左边的变量 |

**复合赋值运算符**

| 运算符 | 描述             | 备注              |
| ------ | ---------------- | ----------------- |
| +=     | 加法赋值运算法   | a+=b等效于a=a+b   |
| -=     | 减法赋值运算法   | a-=b等效于a=a-b   |
| *=     | 乘法赋值运算法   | a*=b等效于a=a*b   |
| /=     | 除法赋值运算法   | a/=b等效于a=a/b   |
| //=    | 取整除赋值运算法 | a//=b等效于a=a//b |
| %=     | 取余赋值运算法   | a%=b等效于a=a%b   |
| **=    | 幂赋值运算法     | a**=b等效于a=a**b |

### 3.3、逻辑运算符


| 运算符 | 描述 | 备注                       |
| ------ | ---- | -------------------------- |
| not    | 非   | 相当于“反义词”           |
| and    | 和   | 条件同时为真，才可以是真   |
| or     | 或   | 条件有一个为真，结果就为真 |
三个逻辑运算符的优先级为：

``` python
not > and > or
```

### 3.4、字符串大小的比较
在程序中，字符串所用的所有字符如：
- 大小写英文单词
- 数字
- 特殊符号(!、\、|、@、#、空格等)


都有对应的ASCII码值表，每一个字符都能对应上一个：数字的码值


- 字符串进行比较大小就是基于数字的码值大小进行比较的
- 从头到尾，按位对应比较，只要有一位大，那么整体就大(后面就无需比较了)

> 例如：
> abc和abd比较(d比c大，那么abd就大)
> a和ab比较(a和a一样，b就大，那么ab就大)

## 四、字符串的处理
### 4.1、字符串的拼接(+)
使用"+"号拼接
语法：

``` javascript
"字面量" + 非数字变量
```

特点：
只能字符串之间进行拼接，非字符串无法拼接

 
 ### 4.2、字符串的格式化(%)

 通过%来占位，后面的变量来替换%
 语法：
 ``` gcode
"%s %f" % (变量1,变量n)
```
 常用的占位符有三个：
 - 字符串： %s 
 - 整型：%d 
 - 浮点型：%f 

特点：
- 多个变量需要使用（）括起来,并按照占位的顺序填入变量
- 可以对精度控制
- 对数据类型进行区分
例子：
``` ini
 name = "tanglx"
 qq = 54312795
 Height = 1.75
 message = "我叫%s"%name
 Message = "我叫%s,升高%是,qq是%s"%(name,Height,qq)
 Message_2 = "我叫%s,升高%f是,qq是%d"%(name,Height,qq)
```



 
 
 ### 4.3、字符串格式化的精度控制(%)
精度控制的语法：

``` gcode
"m.n%s .n%f" % (变量1,变量n)
```
特点：
- m.n的形式控制，m是宽度，n是小数精度
- m和.n均可以忽略，根据需要可以单独写
- m比字符本身宽度还小的时候，m不生效
- .n会对小数部分做精度限制同时会对小数进行四舍五入

例子：

``` javascript
name = "tanglx"
int = 21
height = 1.75

print("宽度为不限制：%s"%name)
print("宽度限制为7：%7s"%name)
print("不设置精度：%f"%height)
print("设置精度为2：%.2f"%height)
print("设置宽度为7,精度为1:%7.1f"%height)
```
### 4.4、 字符串的格式化(format)
对精度没有要求的时候可以快速使用
语法：

``` python
f"{变量1}{变量n}"
```

特点：
- 不理会类型
- 不做精度控制
例子：

``` javascript
name = "tanglx"
age = 21
height = 1.75
print(f"我叫{name},今年{age},身高{height}")
```
### 4.5、对表达式进行格式化
表达式：
表达式就是一个明确是结果的例句

语法： 

``` javascript
f"{表达式}"
"%s"%(表达式)
```

例子:

``` python
print("1*1的结果是：%s"%1*1)
print(f"1*1的结果是:{1*1}")
print("字符串在python中的格式类型是:%s"% type('字符串'))
```

### 4.6、字符串的转义
也叫转义符，比如\n表示换行、\t表示制表符(tab)

#### 4.6.1、取消转义
通常如果要把一个链接或者文件路径写为字符串时特殊字符会被识别为转义符，这时候就需要用到取消转义

**全部取消：**
语法：
`r " "`
实例：
``` python
file = r"C:\Users\tanglx\Documents\me\study\python\execise\八、函数"
print(f"取消全部转义：{file}")
```

**针对性取消:**
语法：
`\`
示例：

``` python
file = "C:\\Users\\tanglx\\Documents\\me\\study\\python\\execise\\八、函数"
print(f"针对性取消转义：{file}")
```

## 五、数据输入
语句：

``` javascript
变量 = input("提示内容")
```

特点：
- 输入数据类型默认为字符串，需要其它类型需要自行转换

例子：

``` javascript
input的几种写法：
name = input()		#直接把输入输入数据给变量
name = input("输入：") # 先打印内容"输入："，再进行
age = int(input())  #输入后转换为int型
```

## 六、 判断语句
### 6.1、布尔类型和比较运算符
布尔类型
- True 真 (1)
- False 假 (0)
 
比较运算符
- == != > < >= <=

``` javascript
通过比较运算符可以得到布尔结果
```

### 6.2、if语句的基本格式
语句：

``` javascript
if 条件:
    成立则执行的语句1
	成立则执行的语句n
```

注意事项：
- 条件可以用表达式的写法
- if语句判断的结果必须是布尔类型True或Flase
- Ture会继续执行，Flase则跳过
- 归属于if代码块的语句前面必须有四个空格
### 6.3、if else 语句
语句：

``` javascript
if 条件:
    成立则执行的语句1
	成立则执行的语句n
else :
    不成立则执行的语句1
	不成立则执行的语句n
```

注意事项：

- 和if代码块一样，需要在执行代码块前面加入四个空格
- else后，不需要成立
### 6.4、if elif else 语句
语句：

``` python
if 条件1:
    条件1成立则执行的语句1
	条件1成立则执行的语句n
elif 条件2:
    条件1不成立则执行的语句1
	条件1不成立则执行的语句n
elif 条件3:
    条件2不成立则执行的语句1
	条件2不成立则执行的语句n
else :
    都不成立则执行的语句1
	都不成立则执行的语句n
```

注意事项：
- 条件可以用表达式的写法
- elif可以写多个
- 条件是互斥且是有顺序的
- 条件成立后则不会执行后面的条件以及else
### 6.5、判断语句的嵌套
语句：

``` python
if 条件:
    if 条件：
	else 条件：
elif 条件:
    if 条件：
	else 条件：	
else :
    if 条件：
	else 条件：
```


注意事项：
- - 判断语句用于多条件，多层次的逻辑判断
- 嵌套判断可以更具需求，自由组合 if elif else来构成多层次判断
- 判断语句一定要注意空格缩进，python通过空格缩进确定层次关系

## 七、循环
### 7.1、 while循环基础
语句：

``` python
i = 0
while i<100:
	执行语句
	i+=1
```

注意事项：
- while的条件需得到布尔类型，True表示继续循环，False表示结束循环
- 需要设置循环终止条件，如i+=1 配合 i<100 就能确保100此之后停止，否则将无限循环
- 空格缩进和if判断一样，都需要设置
### 7.2 、while循环嵌套
语法：

``` python
while 条件1:
	满足条件1时，要做的事情1
	满足条件1时，要做的事情2
	满足条件1时，要做的事情3
	while 条件2：
		满足条件2时，要做的事情1
		满足条件2时，要做的事情2
		满足条件2时，要做的事情3
```

注意事项：
- 通过空格缩进来确定嵌套关系
- 注意条件的控制，避免无限循环
### 7.3、 for循环基础
#### 7.3.1、for循环基础语法
for循环和while区别：
- while 循环的循环条件是自定义的，自行控制循环条件
- for循环是一种”轮询“机制，是对一批内容进行”逐个处理“
  
语法：

``` python 
for 零时变量 in 被处理的数据集(序列):
	满足条件执行的代码
```

注意事项：
- for循环本质上是遍历
- 同while循环不同，for循环无法定义循环条件。
- 只能从被处理的数据集中，依次取出内容内容进行处理
- python的for循环无法构建无线循环(被处理的数据不可能无限大)

#### 7.3.2、range语句
range语句的功能是：
- 获得一个数字序列

语法：
语法1：

``` maxima
range(num)
# 从0开始，到num结束(不含num本身)
```

语法2：

``` stylus
range(num1,num2)
# 从num1开始，到num2结束(不含num2本身)
```

语法3：

``` maxima
range(num1,num2,step)
# 从num1开始，到num2结束,step为步长
```

#### 7.3.3、for循环的零时变量
for循环中的零时变量作用域限定为循环内使用
如果要规范使用零时变量需要在循环前定义好零时变量

注意事项：
- 非强制限定
- 不遵守也能运行，但是不建议这样做
- 如果要访问零时变量，可以预先在循环外定义它

### 7.4 、for循环嵌套
语法：
使用range序列的方式控制循环次数，或使用数据集
``` python
for i in range(1,101):
	print("i")
	for j in range(1,11)
		print(j)
```

注意事项：
- 和while一样，空格缩进来确定嵌套关系
 - 也可以和while搭配嵌套使用

### 7.5、循环中断(break和continue)
**continue**
continue关键字用于：中断本次循环，直接进入下一次

语句：

``` python
for i in range(1,101):
	print("语句1")
	continue
	print("语句2")
	
#直接跳过语句2

```

**break**
break关键字用于：直接结束循环

注意事项：
- continue和break，在for循环和while循环中作用一样
- 在嵌套循环中，只能作用在所在循环上，无法对上层循环起到作用

## 八、函数
函数：组织好的、可重复使用的、用来实现特定功能的代码段
函数的优点：
- 将功能封装在函数内，可供随时随地重复利用
- 提高代码的复用性、减少重复代码，提高开发效率 
### 8.1、函数的基础定义

语法：

``` python
#函数定义
def 函数名(传入参数)
	函数体
	return 返回值
#函数调用
函数名(传入参数)
#或者
接收变量= 函数名(传入参数)
	
```
定义函数时候提供的参数称之为：形式参数(形参)
调用函数时候传入的参数称之为：实际参数(实参)
  注意事项：
  - 定义的参数和返回值可以不写
  - 定义的参数可以写多个
  - 函数先定义后使用

### 8.2、函数返回值的定义
函数返回值：函数在执行完成后，返回给调用者的结果
语法：

``` python
#函数定义
def 函数名(传入参数)
	函数体
	return 返回值
#接收return返回值
接收变量 = 函数名(传入参数)	
```
注意事项：
- 函数在遇到return后就结束了，所以写在return后的代码不会执行


### 8.3、函数中的None类型
None作为一个特殊的字面量，用于表示：空、无意义、具有非常多应用场景

函数中如何返回None：
- 函数中如果不写return，则默认返回None
- 手动写return None

应用场景：
- 用在函数无返回值上
- 用在if判断上
  - 在if判断中，None等同于False
  - 一般用于在函数中主动返回None，配合if判断做相关处理
- 用于声明无内容的变量上
  - 定义变量，但暂时不需要变量有具体值，可以用None来代替

### 8.4、函数说明文档
对函数进行说明解释，帮助更好的理解函数功能

语法:
先写完函数体最后在最上方写""" """并回车，就会自动补充说明格式
``` python
def add(x,y):
    """
   add函数用于将两个值相加并返回结果
    :param x:两个数相加的其中一个值
    :param y:两个数相加的另一个值
    :return:返回两个数相加的结果
    """
    result = x+y
    print(f"{x}+{y}={x+y}")
    return result
```


注意事项：
- 自动补充函数说明文档格式和查看函数说明文档都是pycharm提供的功能
- 先写完函数体，最后在函数最上写""""""就会自动补充说明格式
- 查看函数说明文档鼠标悬停在函数体上

### 8.5、函数的嵌套应用
函数的嵌套应用就是定义一个函数时候调用到另外一个函数

语法：

``` python
def func_a():
    print("---func_a---")

def func_b():
    func_a()
    print("---func_b---")

func_b()


```

### 8.6、变量在函数中的作用域
变量的==作用域 #EE3F4D==指的是==变量作用的范围 #EE3F4D==
#### 8.6.1 局部变量
定义在函数体内的变量，只在函数体内生效

示例：

``` python
def testA():
    num = 100
    print(num)
    return num

testA()

print(num)	#使用函数内变量会提示报错
```

注意事项：
- 局部变量只在函数体内生效

#### 8.6.2 全局变量
在函数内、外都能同时使用的变量
全局变量定义：
- 函数外定义好变量，就能够作为全局变量

示例：

``` python
num = 100	#全局变量
def testA():   #定义函数
    print("函数内：",num)
    return num
testA()   #调用函数
print("函数外：",num)
```

函数不会改变全局变量：

``` python
num = 100
def testA():
    num = 200
    print("函数中的num=",num)

testA()
print("函数外的num=",num)
```

函数体通过global修改全局变量:

``` python
num = 100
def testA():
    global num	#声明变量
    num = 200
    print("函数体内num=",num)

testA()
print("函数体外num=",num)
```

注意事项：
- 全局变量可以在函数内外同时使用
- 函数内改变全局变量的值，函数外不生效
- 要在函数体内修改全局变量可以使用global声明变量

## 九、数据容器
一种可以`容纳多份数据`的数据类型，容纳的`每一份数据称之为1个元素`，每一个元素，可以是`任意类型`的数据，如字符串，数字，布尔等。

数据容器根据特点的不同，如：
- 是否支持重复元素
- 是否可以修改
- 是否有序，等
分为5类，分别是：
列表(list)、元组(tuple)、字符串(str)、集合(set)、字典(dict)

### 9.1、列表(list)
#### 9.1.1、列表的定义语法：

``` python
#字面量
[元素1,元素2,元素3,元素4,...]

#定义变量
变量名称 = [元素1,元素2,元素3,元素4,...]

# 定义空列表
变量名称 = []
变量名称 = list()

# 嵌套定义
变量名称= [变量名称1,变量名称2]

```

列表内的`每一个数据，称之为元素`
- 以[]作为标识 
- 列表内每一个元素用，逗号隔开

#### 9.1.2、列表的特点：
- 可以容纳多个元素（上限为2**63-1、9223372036854775807个）
- 可以容纳不同类型的元素(混装)
- 数据是有序存储的(有下标序号)
- 允许重复数据存在
- 可以修改(增加或删除元素等)

#### 9.1.3、列表的下标(索引)
列表的梅一个元素，都有编号称之为下标索引
 
 正向索引：
 - `my_list[下标]` 从0开始，依次递增，以n-1为结束(n为列表长度)
 
 反向索引：
 - `my_list[下标]` 从-1开始，依次递减，以-n为结束(n为列表长度)
 
示例：

``` python
#定义列表
my_list = ['tom','any','rose']

#正向索引
print(my_list[0])
print(my_list[1])
print(my_list[2])

#反向索引
print(my_list[-1])
print(my_list[-2])
print(my_list[-3])
```

列表嵌套的索引：
- `my_list = [['a1','a2','a3'],['b1','b2','b3']]`my_list[0][0]，第一个括号[0]代表第一个元素，第二个括号[0]代表第一个列表中的第一个元素


示例：
``` python
#嵌套索引
name1=['Tom','Ane','Leo']
name2=['Tom2','Ane2','Leo2']
name3=[name1,name2]

print(name3[0][2])	#括号[0]代表第一个列表，[2]代表第一个列表中的第三个元素
```

#### 9.1.4、列表的操作（方法）
列表的操作称为`方法` 

> 方法：
> 方法和函数功能一样，有传入参数，有返回值，只是方法的使用格式不同
> 定义了一个Student：类
> 方法的使用：
> `变量=类.方法(参数1,参数2)`


**插入元素：**
功能：在指定的下标位置，插入指定的元素
语法：`列表.insert(下标,元素)`

**追加元素：**
追加单个元素:
功能：将指定元素，追加到列表尾部
语法：`列表.append(元素)`

追加多个元素：
功能：将其它数据容器的内容取出，依次追加到列表尾部
语法：`列表.extend(其它数据容器)`

**删除元素：**
下标指定法：
功能：通过指定下标删除列表中的元素
语法1：`del 列表(下标)`
语法2：`列表.pop(下标)`

元素匹配法：
功能：删除某元素在列表中的第一个匹配项
语法：`列表.remove(元素)`

**清空列表：**
功能：清空列表内容
语法：`列表.clear()`

**查找元素：**
查找某元素的下标
功能：查找某元素的下标，如果找不到，报错ValueError
语法：`列表.index(元素)`


**统计元素个数:**
统计某个元素个数：
功能：统计某一个元素在列表中的个数
语法：`列表.count(元素)`

统计列表中的所有元素：
功能：用len函数统计列表中元素的个数
语法：`len(列表)`

**修改元素：**
功能：修改指定下标的元素
语法：`列表[下标]=新元素`


#### 9.1.5、列表的循环遍历
while循环和for循环遍历列表，都是循环语句，但细节不同：
- 在循环控制上：
  - while循环`可以自定循环条件`，并自行控制
  - for循环`不可以自定循环条件`，只可以一个个从容器中取出数据

 - 在无限循环上：
   - while循环`可以`通过条件控制做到无限循环
   - for循环理论上`不可以`，因为被遍历的容器容量不是无限的

- 在使用场景上：
  - while循环适用于任何想要循环的场景
  - for循环适用于，遍历数据容器的场景或简单的固定次数循环场景
### 9.2、元组(tuple)
可以把元组理解为`只读的列表`

#### 9.2.1、元组的定义格式
元组的定义：定义元组使用`小括号`,且使用`逗号`,隔开各个数据，数据可以是不同的数据类型。

``` python
#定义元组字面量
(元素,元素,.....,元素)
#定义一个元素的元组
变量名称 = (元素,)
#定义元组变量
变量名称 = (元素,元素,....,元素)
#定义空元组
变量名称 = ()		#方式1
变量名称 = tuple()	#方式2
```

注意事项：
	- 只有一个元素的元组带上`,`号，定义时候也要带上
	- 元组和列表本质上一样，只是元组不能篡改内容


#### 9.2.2、元组的特点
多数特征和list一样，只是不能修改元素
元组的特点：
- 可以容纳多个数据
- 可以容纳不同的数据(混装)
- 数据是有序存储的(下标索引)
- 允许重复数据存在
-  `不可以修改`(增加或删除元素等)
-  元组中嵌套列表(list),不影响修改list


#### 9.2.3、元组的操作

**查找元素：**
查找某元素的下标
功能：查找某元素的下标，如果找不到，报错ValueError
语法：`元组.index(元素)`

**统计元素个数:**
统计某个元素个数：
功能：统计某一个元素在元组中的个数
语法：`元组.count(元素)`

**统计列表中的所有元素：**
功能：用len函数统计元组中元素的个数
语法：`len(元组)`
### 9.3、字符串(str)
字符串同样属于数据容器的一员，`字符串是字符的容器`，一个字符串可以存放任意数量的字符，`每一个字符叫做元素`

#### 9.3.1、字符串的下标索引
和其它容器如：列表、元组一样，字符串同样通过下标访问
- 从前先后，下标从0开始
- 从后先前，下标从-1开始

语法：

``` python
name = "tanglx"
print(name[0])
print(name[-1])
```

#### 9.3.2、字符串的特点

- 字符串中的元素不可以被修改
- 只可以存储字符串
- 长度任意（取决于内存）
- 支持下标索引
- 允许重复字符串存在
- 支持for循环

#### 9.3.3、字符串的操作

**查找元素：**
查找某元素的下标
功能：查找某元素的下标，如果找不到，报错ValueError
语法：`字符串.index(元素)`

**统计元素个数:**
统计某个元素个数：
功能：统计某一个元素在字符串中的个数
语法：`字符串.count(元素)`

**统计列表中的所有元素：**
功能：用len函数统计字符串中元素的个数
语法：`len(字符串)`

**字符串的替换：**
替换字符后获得一个新的字符串，不改变原有字符串
功能：虽然字符串不能修改元素，但是可以修改并生成新字符串
语法：`字符串.replace(old字符，new字符)`

**字符串的分割：**
字符串本身不变，而是得到一个列表对象
功能：按照指定的分隔符字符串，将字符串划分为多个字符串，并存入`列表对象`
语法：`字符串.split(分隔符字符串)`

**字符串的规整操作：**
字符串的规整操作(不传入参数，去首尾空格)
语法：`字符串.strip()`

字符串的规整操作(去首尾指定字符串)
语法：	`字符串.strip(字符串)`
注意：例如传入的"12",其实是"1"和"2"都会移除，按照单个字符

### 9.4、数据容器(序列)的切片
#### 9.4.1、序列
序列是指：内容连续、有序，可以使用下标索引的一类数据类型

> 列表、元组、字符串，均可以视为序列。

#### 9.4.2、序列的操作
##### 切片：
切片：从一个序列中，取出一个子序列(列表，元组，字符串，均支持进行切片操作)

语法：`序列[起始下标:结束下标:步长]`==取值不包含结束下标 #EE3F4D==
功能：表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列
- 起始下标表示从何处开始，可以留空，留空则从头开始
- 结束下标(不含)表示何处结束，可以留空，留空则截取到结尾
- 步长表示，依次取元素的间隔
   - 步长1表示，一个个取元素
   - 步长2表示，每次跳过一个元素
   - 步长n表示，每次跳过n-1个元素
   - 步长为负数表示，反向取(注意，起始下标和结束下标也要反向标记)`例如:list_1[5:0:-1]`例如：`list_1[::-1]`

### 9.5、集合(set)
集合是无序的(不支持下标索引)，且不支持重复元素，但是集合和列表一样，是允许修改的
#### 9.5.1、集合定义格式

和列表、元组、字符串定义基本相同：
- 列表使用：[]
- 元组使用：()
- 字符串使用：""
- 集合使用：{}

基本语法：

``` python
# 定义集合字面量
{元素,元素,....,元素}
#定义变量
变量名称 = {元素,元素,...元素}
#定义空集合
变量名称 = set()
```

#### 9.5.2、集合的特点

- 不允许重复数据存在
- 元素没有下标(无序)
- 支持修改
- 可以容纳多个数据
- 可以容纳不同类型的数据(混装)
- 支持for循环

#### 9.5.3、集合的操作

**添加新元素：**
功能：将一个指定元素，添加到集合1中(改变集合1)
语法：`集合1.add(元素)`

**2个集合合并：**
功能：将集合1和集合2组合
语法：`新集合=集合1.unior(集合2)`
示例：

``` python
set1 = {1,2,3}
set2 = {1,4,5}
set3 = set1.unior(set2)	#结果：{1,2,3,4,5}
```

**移除元素：**
功能：将指定元素，从集合内移除
语法：`集合.remove(元素)`

**清空集合：**
功能：清空集合
语法：`集合.clear()`

**集合的遍历：**
功能：依次取出元素
语法：`for x in 元素:`

**随机取出元素：**
功能：从集合中随机取出一个元素，取出的元素会从集合中移除
语法：`集合.pop()`

**统计元素个数：**
功能：统计集合中元素个数
语法：`len(集合)`

**取出2个集合的差集：**
功能：取出集合1有集合2没有的元素
语法：`集合1.difference(集合2)`

**消除2个集合的共同值：**
功能：消除集合1内和集合2相同的元素。(改变集合1)
语法：`集合1.difference_update(集合2)`

### 9.6、字典、映射(dict)
字典可以实现基于Key检索Value的场景实现

#### 9.6.1、字典的定义格式
字典的定义，同样使用{}，不过存储的元素是一个个的：`健值对`，如下语法：

``` python
#定义字典字面量
{key:value,...,key:value}
#定义字典变量
my_dict = {key:value,key:value,...,key:value}
#定义空字典
my_dict = {}
my_dict = dict()
#获取key中的元素
my_dict[key]
```

#### 9.6.2、字典的嵌套
- 字典的Key和Value可以是任意数据类型(key不可以为字典)

``` python
# 定义嵌套字典
my_dict3 = {
    10710401:["leo","2002","男","99"],
    10710402:["tom","2002","男","89"],
    10710403:["alis","2001","女","90"]
} 
```

#### 9.6.3、字典的特点
- 字典内key不允许重复(重复会覆盖原有数据)
- 健值对的key和Value可以是任意类型(key不以为字典)
- 字典不可以通过下标索引，而是通过key索引对应Value值
- 可以容纳多个数据
- 可以修改(增加或删除更新元素等)
- 支持for循环

#### 9.6.3、字典的操作
**新增元素**
功能：如果字典中不存在指定key，那么就会新增加
语法：`字典[new_Key] = Value`

**更新元素**
功能：如果字典中存在指定key，那么Vlaue值就会被替换
语法：`字典[old_Key] = Value`

**删除元素**
功能：删除指定字典中的Key
语法：`字典.pop(Key)`

**清空字典**
功能：清空字典
语法：`字典.clear()` 

**获取全部Key**
功能：获取到字典中的全部key(不包含Value)
语法：`接受变量=字典.keys`(获取全部value，用字典.Values)

**统计字典元素数量**
功能：统计字典元素数量
语法：`len(字典)`

**字典的遍历**
功能：依次遍历key
语法：

``` python
test_dict = {key1:Value1,key2:Value2}
for x in test_dict:
    print(f"{x}={test_dict[x]}")
```

### 9.7、数据容器的对比
数据容器可以从以下视角进行简单的分类：

|          | 列表                               | 元组                               | 字符串             | 集合                   | 字典                         |
| -------- | ---------------------------------- | ---------------------------------- | ------------------ | ---------------------- | ---------------------------- |
| 元素数量 | 支持多个                           | 支持多个                           | 支持多个           | 支持多个               | 支持多个                     |
| 元素类型 | 任意                               | 任意                               | `仅字符`           | 任意                   | key:除字典；Value:任意       |
| 下标索引 | 支持                               | 支持                               | 支持               | `不支持`               | `不支持`                     |
| 重复元素 | 支持                               | 支持                               | 支持               | `不支持`               | `不支持`                     |
| 可修改性 | 支持                               | `不支持`                           | `不支持`           | 支持                   | 支持                         |
| 数据有序 | 是                                 | 是                                 | 是                 | `否`                   | `否`                         |
| 使用场景 | 可以修改、可重复的一批数据记录场景 | 不可修改，可重复的一批数据记录场景 | 一串字符的记录场景 | 不可重复的数据记录场景 | 以Key检索Value的数据记录场景 |



**是否支持下标索引**
- 支持：列表、元组、字符串 ---序列类型
- 不支持： 集合、字典 ---非序列类型


**是否支持重复元素**
- 支持：列表、元组、字符串 ---序列类型
- 不支持： 集合、字典 ---非序列类型


**是否可以修改**
- 支持：列表、集合、字典
- 不支持：元组、字符串

### 9.8、数据容器的通用操作
数据容器尽管各自有各自的特点，但是它们也有通用的一些操作。

#### 9.8.1、遍历
尽管遍历的形式各有不同，但是，他们都支持遍历操作
- 5类数容器都支持for循环遍历
- 列表、元组、字符串都支持while循环，集合，字典不支持(无法下标索引)

#### 9.8.2、数据容器的通用统计功能

统计容器的元素个数：
语法：`len(容器)`

统计容器的最大元素：
语法：`max(容器)`

统计容器的最小元素：
语法: `min(容器)`	

#### 9.8.3、容器的通用转换功能

将指定容器转换为列表：
语法：`list()`

将指定容器转换为字符串：
语法：`str()`

将指定容器转换为元组：
语法：`tuple()`

将指定容器转换为集合：
语法：`set()`

#### 9.8.3、容器的通用排序功能
将给定容器进行排序：

从小到大排序：
语法：`sorted(容器,[reverse=True])`

从大到小排序：
语法：`sorted(容器,reverse=True)`


## 十、函数的进阶

### 10.1、函数的多返回值
如果一个函数要有多个返回值
语法：

``` python
def test_return():
	return 1,2
	
x,y = test_return()	#用两个变量接收
print(x)	#1
print(y)	#2
```

- 按照返回值的顺序，写对应顺序的多个变量接收接收即可
- 变量之间用逗号隔开
- 支持不同类型的return

### 10.2、函数的多种参数使用形式

#### 10.2.1、位置参数
位置参数：调用函数时根据函数定义的`参数位置来传递参数`
语法：

``` python
def uesr_info(name,age,gender):
	print(f"名字是{name},年龄是{age},性别是{gender}")
user_info('tom',20,'男')
```

注意事项：
-   传递参数和定义的参数的顺序及个数必须一致

#### 10.2.2 关键字参数
关键字参数：函数调用时通过 `健=值 `形式传递参数

作用：可以让函数更加清晰，容易使用，同时也清除了参数的顺序需求

语法：

``` python
def uesr_info(name,age,gender):
	print(f"名字是{name},年龄是{age},性别是{gender}")
#可以不固定位置传入参数
user_info(age=20,gender="男",name="小明")
#可以和位置参数混用，位置参数必须在前，且匹配参数顺序
user_info(小明,age=20,gender="男")
```

注意事项:
- 函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字之间不存在先后顺序

#### 10.2.3 缺省参数
缺省参数：缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可以不传该默认值

作用：当调用函数时没有传递参数，就会使用默认是用缺省参数对应的值。

语法：

``` python
def uesr_info(name,age,gender='男'):
	print(f"名字是{name},年龄是{age},性别是{gender}")
#使用默认值
user_info('tom',20)
#不使用默认值
user_info('Rose',20,'女')
```

注意事项：
- 所有位置参数必须出现在默认前，包括函数定义和调用

#### 10.2.4 不定长参数
不定长参数：不定长参数也叫可变参数，用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。

作用：当调用函数时不确定个数时，可以使用不定参数。

不定长参数的类型：
1.位置传递
形参使用`*`号，传入的值作为元组存在
语法：

``` python
#不定长参数_位置传递
def user_info(*args):
    print(f"类型是{type(args)},值为:{args}")

user_info(18,17,16,18)
```

2.关键字传递
形参使用`**`号，传入的值作为字典存在
``` python
#不定长参数_关键字传递
def user_info(**kwarg):
    print(f"类型是{type(kwarg)},值为:{kwarg}")

user_info(a1=1,a2=2,a3=3)
```

### 10.3、函数作为参数传递
- 函数本身是可以作为参数，传入另一个函数中使用的
- 将函数传入的作用在于：传入计算逻辑，而非传入数据

示例：

``` python
def test_func(compute):
	result = compute(1,2)
	print(result)

def compute(x,y)
	return x+y

test_func(compute)
```

### 10.4、lambda匿名函数
函数定义中
- def关键字，可以定义`带有名称`的函数
- lambda关键字，可以定义`匿名函数`(无名称)

有名称的函数，可以基于名称`重复使用`
无名称的匿名函数，只可以`零时使用一次`

语法：

``` python
lambda 传入参数:函数体(一行代码)
```
- lambda是关键字，表示定义匿名函数
- 传入参数表示匿名函数的形式参数，如：x,y表示2个形式参数
- 函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行

示例：

``` python
def test_func(compute):
	result = compute(1,2)
	print(result)

test_func(lambda x,y:x+y)
```